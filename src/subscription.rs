use crate::bluetooth::{self, Command, BDAddr};

use iced::{
    futures::{
        self, channel::mpsc, sink::SinkExt, 
        Stream, StreamExt,
    },
    stream, 
};

/// A builder for an asynchronous worker with bidirectional communication that manages Bluetooth connections.
///
/// This asynchronous worker facilitates the setup and handling of the Bluetooth connection process,
/// including discovering peripherals, establishing connections, and handling communication.
/// 
/// ## Use 
/// It's intended to be used as an [`iced::Subscription`]
/// 
/// ```no_run
/// Subscription::run(bluetooth_connection);
/// ```
/// 
/// ## See also
/// - [`Event`] for details on events emitted by the subscription.
pub fn bluetooth_connection() -> impl Stream<Item = Event> {
    stream::channel(100, |mut output| async move {
        let (sender, receiver) = mpsc::channel(100);
        
        let central = bluetooth::Central::new().await.expect("Error creating bluetooth client");
        let peripherals = central.scan().await.expect("Error scanning peripherals");

        let _ = output.send(Event::Disconnected { peripherals: peripherals.clone(), sender }).await;
        let mut state = ConnectionState::Disconnected { peripherals, receiver };

        log::info!("The first connection state: {state:#?}");

        loop {
            match &mut state {
                ConnectionState::Connected { xplorer, receiver } => {
                    let mut notifications = xplorer.notifications().await.expect("Error get the notifications");

                    futures::select! {
                        cmd = receiver.select_next_some() => {
                            if let Err(err) = xplorer.send(cmd).await {
                                let _= output.send(Event::Err(err.to_string())).await;
                            } else {
                                log::debug!("Command sent: {cmd:?}");
                            }
                        }

                        notification = notifications.select_next_some() => {
                            let cmd = Command::from(notification.value);
                            let _= output.send(Event::CommandReceived(cmd)).await;

                            log::debug!("Command received: {cmd:?}");
                        }
                        
                    }
                },
                ConnectionState::Disconnected { peripherals, receiver } => {
                    let addr = receiver.select_next_some().await;               
                    log::info!("Trying connect to: {addr}");

                    let (id, _properties) = match bluetooth::search(peripherals, addr) {
                        Ok(value) => value,
                        Err(err) => {
                            let _= output.send(Event::Err(err.to_string())).await;
                            continue;
                        }
                    };

                    let xplorer = match central.connect(&id).await {
                        Ok(xplorer) => xplorer,
                        Err(err) => {
                            let _= output.send(Event::Err(err.to_string())).await;
                            continue;
                        }
                    };

                    let (sender, receiver) = mpsc::channel(100);

                    let _ = output.send(Event::Connected { addr, sender }).await;
                    state = ConnectionState::Connected { xplorer, receiver };
                    
                    log::info!("The connection state changed to: {state:#?}");
                },
            }
        }
    })
}

/// The events generated by the subscription: [`bluetooth_connection`]
#[derive(Debug, Clone)]
pub enum Event {
    /// Emitted when a connection is successfully established with a peripheral.
    Connected {
        addr: BDAddr,
        sender: mpsc::Sender<Command>,
    },

    /// Emitted when a command is received.
    CommandReceived(Command),
    
    /// The initial event, indicating that there is no connection to any peripheral.
    Disconnected {
        peripherals: bluetooth::Peripherals,
        sender: mpsc::Sender<bluetooth::BDAddr>,
    },
    
    /// Emitted when an error occurs.
    Err(String),
}

/// Represents the connection state of the Bluetooth communication
#[derive(Debug)]
enum ConnectionState {
    /// Represents the connected state and contains the peripheral to which it is connected.
    Connected {
        xplorer: bluetooth::Xplorer,
        receiver: mpsc::Receiver<Command>,
    },

    /// Represents the disconnected state and contains a list of peripherals to which it can connect.
    Disconnected {
        peripherals: bluetooth::Peripherals,
        receiver: mpsc::Receiver<BDAddr>
    },
}
